Common Experience: Command Line Interface (technical spec notes)
================================================================

Since we want to minimize the code footprint of the CE system, we want to be able to build as much as possible
from as few building blocks as possible. Therefore the Command Line Interface is also structured around this
"building more from less" concept. We take shell pipes as our example and try to make them as lean as possible.

Each CE command line can internally run a simple pipeline, which is a sequence of individual CE calls that may be linked.

In order to avoid the overhead of operating system's pipes (and running multiple instances of CE interpreter)
we shall use CLI format in "prefix notation" (verb is followed by its parameters "virtually piped" into
another verb followed by its parameters, etc):

    ce --meta_optionX=... --meta_optionY=... --meta_optionZ=...
       verb1 --param1a=... --param1b=... \
       verb2 --param2a=... \
       verb3 --param3a=... --param3b=...

This format is easy to parse, provided all parameters are prefixed with "--" .


Some verbs can have obligatory parameters, which allows us to skip the names of the obligatory parameters
provided the correct order of them is kept:

    ce --meta_optionX=... --meta_optionY=... --meta_optionZ=...
       verb1 oblig1a --option1b=... --option1c=... \
       verb2 --option2a=... \
       verb3 oblig3a oblig3b

This format is still easy to parse, provided we have a quick access to every method's signature.


In the most typical 2-step linked pipeline scenario an entry has to be found/resolved first,
and then a method be called on the result(s).

    # Single-resolution example. Equivalent of 'ck locate env --tags=model,tflite,resnet' :
        ce find1 --query=env,model,tflite,resnet \
           tabulate --fields=location

Note 1. find1() or findN() is a method central to the whole CE system. It searches for entries
        based on tags and attributes. The difference between them is how many results they are
        expected to return (1 vs many).

Note 2. The object that is passed through the "virtual pipe" between the verbs is a CE entry,
        lazily loaded into an internal representation.

Note 3. tabulate() is a data projection method that formats outgoing data into simple tables
        that can be piped out of CE into traditional shell processing scripts.


Using the second format (ordering obligatory parameters instead of naming them) allows to write even less:

    # Single-resolution example. Equivalent of 'ck find env --tags=lib,armnn,rel.19.05,tflite,neon'
        ce find1 lib,armnn,rel.19.05,tflite,neon \
           tabulate entry_path

A resolution may return multiple entries. The following example iterates through them:

    # Multiple-resolution example. Equivalent of 'ck show env --tags=model,onnx,image-classification' :
        ce findN env,model,onnx,image-classification \
           tabulate data_uoa,name,version,tags --header! --format=...


Since we pass an entry between verbs, we might as well make some on-the-fly changes, and even store the result:

    # On-the-spot editing example. Load an entry, make some in-memory changes to its meta data, then store under a different name.
        ce find1 env,model,model_type=tflite \
           tweak --param.x=15 --param.y=20 --meta.z=pqr \
           save --new_name=... --new_collection=...     # these are not properties of the object, but rather of the container collection

Note 1. tweak() is a universal method that allows to edit different types of data according to their nature
        ( override scalars, push/unshift/seek-and-remove arrays, add or remove dictionary entries, etc).

Note 2. save() by default stores changes in the original entry, but if --new_name or --new_collection is given, can make an (edited) copy.


There are also other ways to start the flow.

Finding an entry using its name (way faster than using tags/attribs query, but less portable):

        ce from python-package-tensorflow-1.12 \
           install

        ce from python-package-tensorflow-1.12 \
           tweak --version=1.13 --tags-=v1.12 --tags=+v1.13 \
           save --name=python-package-tensorflow-1.13


It is even possible to start from scratch (assuming an empty entry by default) :

        ce save --name=new_empty_ce_entry_in_dynamic_collection

which can, of course, be modified on the fly:

        ce tweak --alpha=15 --extlist=[png,git,jpg] \
           save  --name=new_ce_entry_in_dynamic_collection

Meta data can also be fed from an external file:

            ce json_input --input_file=xyz.json | ce save --name=...

or from standard input (assuming JSON input) :

            jq ... | ce json_input save --name=...


Multi-environment resolve examples:

    # resolve() runs "find1" on each entry in deps{} , adding "env" type on the fly, and outputs env{} , merged in the correct order
        ce from env \
           resolve --deps.lib.query=lib,tflite --deps.model.query=model,tflite --deps.images.query=preprocessed,imagenet \
           json_output

    # M-to-1 resolution. Equivalent of 'ck virtual env --tag_groups="lib,tflite model,tflite preprocessed,imagenet' :
        ce from env \
           resolve --deps=+{query=lib,tflite} --deps=+{query=model,tflite} --deps=+{query=preprocessed,imagenet} \
           shell --cmd=...


    # Assumes automatic resolve()
        ce find1 program,image-classification,tf,cpp \
            run

    # Test resolve() for a particular program (assumes "program" inherits from "env" - or at least from "resolvable" interface):
        ce find1 program,image-classification,tf,cpp \
            resolve


CLI user-facing commands:
=========================

There is an opportunity to tune the whole CE call by sticking "meta level" options before the first verb:
    ce --core_collection=... --dynamic_collection=... load package-X install
    ce --version

(collection access)
    load/from/with/using <entry_name> [collection=dynamic]  1->1    # finds (and lazily loads) an entry by name
    find1 <query> [collection=dynamic]                      1->1    # finds an entry using query
    findN <query> [collection=dynamic]                      1->N    # finds multiple entries using query
    save [new_entry_relpath] [collection=dynamic]           1->1    # update or store a new entry
    delete                                                  1->1    # removes an entry from its collection

(on-the-fly editing)
    tweak                                                   1->1    # change any aspects of the "current" entry

(input/output)
    json_input [input_file]                                 1->1    # load an entry from STDIN or JSON file
    json_output [output_file]                               N->1    # output JSON to STDOUT or a file
    tabulate <fields> [separator] [format]                  N->1    # output in tabular format

(env/resolvable)
    resolve [deps] [collection=dynamic]                     1->1    # uniquely resolve given deps (defined either in an entry or from cli)
    shell [cmd]                                             1->1    # run shell interactively or a given command in it. Consume environment generated by resolve()

(repo)
    pull <url> <name>                                       1->1    # create a new local collection by cloning a git repo, or pull if it already exists

(env/downloadable/soft/package)
    download <url> [tags] [attribs]                         1->1    # download an external file (defined by URL) and store it as a local entry
    detect [full_path] [search_path]                        1->1    # find a given pre-installed package and set up an environment entry pointing at it
    install [package_version] [package_options]             1->1    # install/build a package in a new entry


To avoid unpredictable behaviour, but still support the concept of "current dir as an entry",
this functionality has to be explicitly required:
    ce from . install
    ce from . detect
Note that entries loaded this way do not know to which collection they belong.
So collection-related operations with the "cwd entry" are discouraged.
